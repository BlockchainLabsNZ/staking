/**
  * FEE tokens do not have limit. A new token can be generated by owner.
  * FEE token will follow ERC20 standards.
  */
pragma solidity ^0.4.11;

import './SafeMath.sol';
import './StandardToken.sol';

contract Fee is StandardToken {

    /* This notifies clients about the amount burnt */
    event Burn(address indexed from, uint256 value);

    string public name;                   //fancy name: eg Simon Bucks
    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.
    string public symbol;                 //An identifier: eg SBX
    uint256 public feeInCirculation;      //total fee in circulation
    string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.
    address public owner;
    address public minter;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    modifier onlyMinter {
        require(msg.sender == minter);
        _;
    }

    modifier addressNotEmpty(address a) {
      require(a != address(0));
      _;
    }

    modifier uintNotEmpty(uint256 number) {
      require(number != 0);
      _;
    }

    modifier stringNotEmpty(string s) {
      require(bytes(s).length != 0);
      _;
    }

    /// @notice Constructor to set the owner, tokenName, decimals and symbol
    function Fee(
      address _owner,
      string _tokenName,
      uint8 _decimalUnits,
      string _tokenSymbol
    )
      public
      addressNotEmpty(_owner)
      stringNotEmpty(_tokenName)
      stringNotEmpty(_tokenSymbol)
    {
      owner = _owner;
      name = _tokenName;
      decimals = _decimalUnits;
      symbol = _tokenSymbol;
    }

    /// @notice To set the owner of the contract
    /// @param _owner The address of the owner
    function setOwner(address _owner)
      public
      addressNotEmpty(_owner)
      onlyOwner
      returns (bool)
    {
      owner = _owner;
      return true;
    }

    /// @notice To set a new minter address
    /// @param _minter The address of the minter
    function setMinter(address _minter)
      public
      addressNotEmpty(_minter)
      onlyOwner
      returns (bool)
    {
      minter = _minter;
      return true;
    }

    /// @notice To eliminate tokens and adjust the price of the FEE tokens
    /// @param _value Amount of tokens to delete
    function burnTokens(uint256 _value)
      public
      uintNotEmpty(_value)
      returns (bool)
    {
      require(balances[msg.sender] >= _value);

      balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);
      feeInCirculation = SafeMath.sub(feeInCirculation, _value);
      Burn(msg.sender, _value);
      return true;
    }

    /// @notice To send tokens to another user. New FEE tokens are generated when
    /// doing this process by the minter
    /// @param _to The receiver of the tokens
    /// @param _value The amount o
    function sendTokens(address _to, uint256 _value)
      public
      addressNotEmpty(_to)
      uintNotEmpty(_value)
      onlyMinter
      returns (bool)
    {
      balances[_to] = SafeMath.add(balances[_to], _value);
      feeInCirculation = SafeMath.add(feeInCirculation, _value);
      Transfer(msg.sender, _to, _value);
      return true;
    }
}
