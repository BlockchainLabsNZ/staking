/**
  * FEE tokens do not have limit. A new token can be generated by owner.
  * FEE token will follow ERC20 standards.
  */

pragma solidity ^0.4.11;


import "tokens/StandardToken.sol";


contract Fee is StandardToken {
    /* This notifies clients about the amount burnt */
    event Burn(address indexed from, uint256 value);

    string public name;                   //fancy name: eg Simon Bucks
    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.
    string public symbol;                 //An identifier: eg SBX
    uint256 public feeInCirculation;      //total fee in circulation
    string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.
    address public owner;

    address public minter;


    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    modifier onlyMinter {
        require(msg.sender == minter);
        _;
    }

    function Fee(address _owner, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) {
        owner = _owner;
        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
    }

    function setOwner(address _owner) onlyOwner returns (bool success) {
        owner = _owner;
        return true;
    }

    function setMinter(address _minter) onlyOwner returns (bool success) {
        minter = _minter;
        return true;
    }

    function burnTokens(uint256 _value) returns (bool success) {
        require(balanceOf(msg.sender) >= _value);
        balances[msg.sender] -= _value;
        feeInCirculation -= _value;
        Burn(msg.sender, _value);
        return true;
    }

    function sendTokens(address _to, uint256 _value) onlyMinter returns (bool success) {
        balances[_to] += _value;
        feeInCirculation +=_value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

}
