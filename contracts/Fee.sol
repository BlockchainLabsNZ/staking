/**
  * FEE tokens do not have limit. A new token can be generated by owner.
  * FEE token will follow ERC20 standards.
  */
pragma solidity ^0.4.11;

import "tokens/StandardToken.sol";

// SafeMath is needed to avoid overflow - underflow problems and security risks
import 'zeppelin-solidity/contracts/math/SafeMath.sol';

contract Fee is StandardToken {
    using SafeMath for uint256;

    /* This notifies clients about the amount burnt */
    event Burn(address indexed from, uint256 value);

    string public name;                   //fancy name: eg Simon Bucks
    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.
    string public symbol;                 //An identifier: eg SBX
    uint256 public feeInCirculation;      //total fee in circulation
    string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.
    address public owner;
    address public minter;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    modifier onlyMinter {
        require(msg.sender == minter);
        _;
    }

    function Fee(address _owner, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) {
      require(_owner != address(0));
      require(_tokenName.length > 0);
      require(_decimalUnits > 0);
      require(_tokenSymbol.length > 0);

      owner = _owner;
      name = _tokenName;
      decimals = _decimalUnits;
      symbol = _tokenSymbol;
    }

    function setOwner(address _owner) onlyOwner returns (bool success) {
      require(_owner != address(0));

      owner = _owner;
      return true;
    }

    function setMinter(address _minter) onlyOwner returns (bool success) {
      require(_minter != address(0));

      minter = _minter;
      return true;
    }

    function burnTokens(uint256 _value) returns (bool success) {
      require(_value > 0);
      require(balances[msg.sender] >= _value);

      balances[msg.sender] = balances[msg.sender].sub(_value);
      feeInCirculation = feeInCirculation.sub(_value);
      Burn(msg.sender, _value);
      return true;
    }

    function sendTokens(address _to, uint256 _value) onlyMinter returns (bool success) {
      require(_to != address(0));
      require(_value != 0);

      // First we have to reduce the balance to avoid reentrancy risks
      balances[msg.sender] = balances[msg.sender].sub(_value);
      balances[_to] = balances[_to].add(_value);
      feeInCirculation = feeInCirculation.add(_value);
      Transfer(msg.sender, _to, _value);
      return true;
    }
}
